// The raw completion script content (for writing to a file)
const completionScript = `#compdef httpyac

# Zsh completion script for httpyac CLI
# https://httpyac.github.io/
# Generated by: httpyac shell-init zsh

_httpyac_output_formats() {
  local formats=(
    'short:Short output format'
    'body:Response body only'
    'headers:Response headers only'
    'response:Full response'
    'exchange:Request and response'
    'timings:Timing information'
    'none:No output'
  )
  _describe -t output-formats 'output format' formats
}

_httpyac_repeat_modes() {
  local modes=(
    'sequential:Run requests sequentially'
    'parallel:Run requests in parallel'
  )
  _describe -t repeat-modes 'repeat mode' modes
}

_httpyac_filter_values() {
  local filters=(
    'only-failed:Show only failed requests'
  )
  _describe -t filters 'filter' filters
}

_httpyac_oauth2_flows() {
  local flows=(
    'client_credentials:Client credentials flow'
    'authorization_code:Authorization code flow'
    'device_code:Device code flow'
    'password:Password flow'
    'implicit:Implicit flow'
    'hybrid:Hybrid flow'
  )
  _describe -t oauth2-flows 'OAuth2 flow' flows
}

_httpyac_extract_region_names() {
  local http_files=()
  local names=()
  local line

  # Find .http files from the command line arguments
  for word in "\${words[@]}"; do
    if [[ "$word" == *.http || "$word" == *.rest ]]; then
      if [[ -f "$word" ]]; then
        http_files+=("$word")
      fi
    fi
  done

  # If no files found in args, try to find in current directory
  if (( \${#http_files[@]} == 0 )); then
    http_files=(*.http(N) *.rest(N))
  fi

  # Extract region names from files
  for file in "\${http_files[@]}"; do
    if [[ -f "$file" ]]; then
      while IFS= read -r line; do
        # Match ### delimiter with title
        if [[ "$line" =~ ^[[:space:]]*#{3,}[[:space:]]*(.+)$ ]]; then
          local title="\${match[1]}"
          title="\${title##[[:space:]]}"
          title="\${title%%[[:space:]]}"
          if [[ -n "$title" ]]; then
            names+=("$title")
          fi
        fi
        # Match @name metadata
        if [[ "$line" =~ ^[[:space:]]*#[[:space:]]*@name[[:space:]]+([^[:space:]]+) ]]; then
          names+=("\${match[1]}")
        fi
      done < "$file"
    fi
  done

  if (( \${#names[@]} > 0 )); then
    local unique_names=(\${(u)names[@]})
    _describe -t region-names 'HTTP region name' unique_names
  fi
}

_httpyac_send() {
  _arguments -s -S \\
    '(-a --all)'{-a,--all}'[Execute all requests in a file]' \\
    '*'{-e,--env}'[List of environments]:environment:' \\
    '--bail[Stop execution on test failure]' \\
    '--filter[Filter output]:filter:_httpyac_filter_values' \\
    '--insecure[Allow insecure SSL connections]' \\
    '(-i --interactive)'{-i,--interactive}'[Interactive mode]' \\
    '--json[JSON output format]' \\
    '--junit[JUnit XML output format]' \\
    '(-l --line)'{-l,--line}'[Line number of the HTTP request]:line number:' \\
    '(-n --name)'{-n,--name}'[Name of the HTTP region]:name:_httpyac_extract_region_names' \\
    '--no-color[Disable colored output]' \\
    '(-o --output)'{-o,--output}'[Output format]:output format:_httpyac_output_formats' \\
    '--output-failed[Output format for failed responses]:output format:_httpyac_output_formats' \\
    '--raw[Do not format response body]' \\
    '(-q --quiet)'{-q,--quiet}'[Quiet mode]' \\
    '--repeat[Number of times to repeat]:count:' \\
    '--repeat-mode[Repeat mode]:mode:_httpyac_repeat_modes' \\
    '--parallel[Number of parallel requests]:count:' \\
    '(-s --silent)'{-s,--silent}'[Only log requests]' \\
    '*'{-t,--tag}'[Tags to execute]:tag:' \\
    '--timeout[Request timeout in milliseconds]:timeout:' \\
    '*--var[Variables]:variable:' \\
    '(-v --verbose)'{-v,--verbose}'[Verbose output]' \\
    '*:HTTP file:_files -g "*.http *.rest"'
}

_httpyac_oauth2() {
  _arguments -s -S \\
    '(-f --flow)'{-f,--flow}'[OAuth2 flow type]:flow:_httpyac_oauth2_flows' \\
    '--prefix[Variable prefix]:prefix:' \\
    '*'{-e,--env}'[List of environments]:environment:' \\
    '(-o --output)'{-o,--output}'[Output format]:output format:_httpyac_output_formats' \\
    '*--var[Variables]:variable:' \\
    '*:HTTP file:_files -g "*.http *.rest"'
}

_httpyac_shell_init() {
  _arguments -s -S \\
    '1:shell:(zsh bash)'
}

_httpyac() {
  local curcontext="$curcontext" state line
  typeset -A opt_args

  _arguments -C \\
    '1: :->command' \\
    '*::arg:->args'

  case $state in
    command)
      local commands=(
        'send:Execute HTTP requests (default)'
        'oauth2:Generate OAuth2 token'
        'shell-init:Generate shell completion script'
      )
      _describe -t commands 'httpyac command' commands
      _files -g "*.http *.rest"
      ;;
    args)
      case \${line[1]} in
        send)
          _httpyac_send
          ;;
        oauth2)
          _httpyac_oauth2
          ;;
        shell-init)
          _httpyac_shell_init
          ;;
        *)
          _httpyac_send
          ;;
      esac
      ;;
  esac
}

# Register completion function if compdef is available
# When loaded via fpath, the #compdef directive handles this automatically
if type compdef &>/dev/null; then
  compdef _httpyac httpyac
fi`;

// Export the completion script
// Usage:
//   1. Save to fpath: httpyac shell-init zsh > "${fpath[1]}/_httpyac"
//   2. Or source in .zshrc: source <(httpyac shell-init zsh)
export const zshCompletionScript = `${completionScript}
`;
